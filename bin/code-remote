#!/bin/bash

# script analysed with https://www.shellcheck.net

readonly try_languages=( "python" "go" "php" "node" "java" "rust" "dotnet" "cpp" "sqlserver" )
readonly USAGE="
USAGE:
       code-remote FOLDER|GIT-URL [WORKSPACEFOLDER]
       code-remote --try|-t LANGUAGE

       LANGUAGE: the following languages are available in a try dev-container: 
                  ${try_languages[@]} 

"

# make script exit early on errors
set -eE  # BEST: traps error in subshell with right linenumber in code
       # -e  Exit immediately if a command exits with a non-zero status.
       # -E  If set, the ERR trap is inherited by shell functions.
       # We set this also for every function, because when in subshells
       # set -eE is not inherited. By setting it in every function we
       # sure it is enabled again. (set -u and set -x is always inherited in subshells)
       # e.g. when calling a function in command substition
       #   manifest_digest=$(get_manifest_digest_for_a_tag_for_a_specific_os_arch "$image" "$tag")
       #                    `-> runs in subshell
set -u # script ends with signal EXIT when unset variable is used
       # also use "local" and "readonly" keywords to limit scope of declared variables
set -o nounset;set -u

vscodegitdir="/tmp/code-remote-git-clones"

# check required commands
if ! command -v code &> /dev/null
then
   echo "ERROR: 'code' commandline command could not be found"
   echo "       Install using Visual Studio Code with \"Install 'code' command in PATH\" command."
   exit 1
fi

function find_in_array() {
  local searchword="$1"
  shift
  for item in "$@"
  do 
      [[ "$item" == "$searchword" ]] && return 0 
  done
  return 1
}

function code-remote-try {
    set -eE 
    local lang="$1"

    if ! find_in_array "$lang" "${try_languages[@]}" 
    then
       echo "ERROR: The language '$lang' is not available in a try dev-container." 
       echo "       Only the following languages are supported: ${try_languages[@]}"
       return 1 
    fi
    local url="https://github.com/microsoft/vscode-remote-try-$lang"
    echo "opening dev container from $url"
    code-remote "$url"
}    
    
function code-remote {   
   set -eE 
   local hostfolder
   local workspacefolder
   local devcontfile
   local backupfile
   local volumename
   local option_allow_workspacefolder_from_json
   local option_volume_mode
     
   option_allow_workspacefolder_from_json="false"
   option_volume_mode="false"

   # parse options
   while [[ "$#" -gt 0 && "$1" == -* ]]
   do
      if [[ "$1" == "--help" || "$1" == "-h" ]]
      then
          echo "$USAGE"
          exit 0
      fi
      if [[ "$1" == "--try" || "$1" == "-t" ]]
      then 
          [[ "$#" -lt 2 ]] &&  echo "$USAGE" && exit 1
          lang="$2" 
          code-remote-try "$lang"          
          exit 0
      fi
      if [[ "$1" == "-f" ]]
      then 
          option_allow_workspacefolder_from_json="true"
          shift
      fi
      if [[ "$1" == "-v" ]]
      then 
          option_volume_mode="true"
          shift
      fi
   done 

   # we must have a single argument
   if [[  "$#" -lt "1" || "$#" -gt "2" ]]
   then
      echo "$USAGE"
      exit 0
   fi 

   # get arguments
   hostfolder="$1"
   if [[  "$#" -eq "2" ]]
   then
       workspacefolder="$2"
   else 
       workspacefolder=""
   fi 

   local volume_mode
   volume_mode="false"

   # get hostfolder 
   if [[ "$hostfolder" == git@* || "$hostfolder" == http* ]] ;
   then
      volume_mode="true"
      local git_url="$hostfolder"

      # http(s):// or git@ only says indirectly something about authentication method  
      # but what comes after it is the real location of the repository
      # strip git@ prefix
      hostfolder=${hostfolder#git@}
      # strip http:// or https:// prefix
      hostfolder=${hostfolder#http://}
      hostfolder=${hostfolder#https://}
      # escape some characters with _
      #hostfolder=$(echo "$hostfolder" | tr ' $%^&*()[]+#!~`?><,;=\\/' '_')
      
      # remove ":" from hostfolder because otherwise local folder may be seen as
      # ssh remote for mirror command
      hostfolder=$(echo "$hostfolder"| tr ':' "_" )
      # remove optional .git suffix 
      hostfolder="${hostfolder%.git}"
      # note: leave slashes in hostfolder so that we can easily derive basename from it

      # have full url encoded in volumename to prevent conflicts
      volumename=$(echo "$hostfolder"| tr '/' "_" )
      volumename="code-remote-volume-${volumename}"
      # final hostfolder is prefixed with vscodegitdir
      hostfolder="$vscodegitdir/$hostfolder"
      
      if [[ -z $(docker volume ls -qf name=$volumename) ]]
      then    
          echo "volume $volumename does not yet exist"

          # first clone git data
          #note git automatically creates all folders in hostfolder which do not exist when cloning to a hostfolder
          if [[  -d "$hostfolder" ]]
          then    
              # cleanup old hostfolder
              rm -rf "$hostfolder"
          fi  
          # clone git folder fresh
          git clone "$git_url" "$hostfolder"
          
          # create named volume
          docker volume create "$volumename" 

          # mirror gitdata in hostfolder into volume
          echo mirror -q --no-warn "$hostfolder" "docker-vol://$volumename"
          mirror -q --no-warn "$hostfolder" "docker-vol://$volumename"
      else    
          echo "volume $volumename does already exist"
      fi

      
   else
       if [[ ! -d "$hostfolder" ]]
       then 
           echo "ERROR: folder '$hostfolder' does not exist"
           exit 1
       fi    
       hostfolder=$(realpath "$hostfolder") 
   fi

   # get devcontainer.json file
   #
   if [[ -e "${hostfolder}/.devcontainer/devcontainer.json"  ]]
   then
       devcontfile="${hostfolder}/.devcontainer/devcontainer.json"
   else  
     if [[ -e "${hostfolder}/.devcontainer.json"  ]]
     then 
         devcontfile="${hostfolder}/.devcontainer.json"
     else
         echo "ERROR: cannot find a devcontainer.json file" 1>&2
         return 1
     fi    
   fi 


   if [[ "$volume_mode" == "true"  ]] 
   then
       # unset workspaceMount and set mounts to used named volume in devcontainer 
       backupfile="${devcontfile}.code-remote-backup"
       cp "$devcontfile" "$backupfile"
       local basemountname
       basemountname=$(basename "$hostfolder")
       cat "$backupfile" | grep -E -v '\s*//' | jq '.workspaceMount = null'  - | jq '.mounts = [{ "source": "'$volumename'", "target": "/workspaces/'$basemountname'", "type": "volume" }]' > "$devcontfile"
   fi    

   # get workspacefolder from devcontainer.json if not given on cmdline
   if [[ "$workspacefolder" == ""  ]] 
   then
       # first check whether some fields are specified in devcontainer.json
       local contains_workspaceFolder="false"
       local contains_image="false"
       local contains_dockerFile="false"
       local contains_dockerComposeFile="false"
       grep -E '^\s*"workspaceFolder' "$devcontfile" 2>/dev/null >/dev/null && contains_workspaceFolder="true"
       grep -E '^\s*"image' "$devcontfile" 2>/dev/null >/dev/null && contains_image="true"
       grep -E '^\s*"dockerFile' "$devcontfile" 2>/dev/null >/dev/null && contains_dockerFile="true"
       grep -E '^\s*"dockerComposeFile' "$devcontfile" 2>/dev/null >/dev/null && contains_dockerComposeFile="true"

       # first verify devcontainer.json file correctly configured 
       if [[ "$contains_dockerComposeFile" == "true" ]]
       then
           if  [[ "$contains_image" == "true" || "$contains_dockerFile" == "true"  ]]
           then
               echo "ERROR: devcontainer config '$devcontfile'" 'cannot have both a "dockerComposeFile" property and an "image" or "dockerFile" property.'
               exit 1           
           fi
           local contains_service="false"
           grep -E '^\s*"service' "$devcontfile" 2>/dev/null >/dev/null && contains_service="true"
           if [[ "$contains_service" == "true" ]]
           then       
              service=$(grep -E  '^\s*"service' "$devcontfile" | sed 's/.*:\s*"//' |sed 's/"\s*,\s*$//')
              echo "opening vscode in devcontainer of service '$service'"
           else       
               echo "ERROR: devcontainer config '$devcontfile'" 'is missing a "service" property'
               exit 1           
           fi                  
       else  
           if ! [[ "$contains_image" == "true" || "$contains_dockerFile" == "true"  ]]
           then
               echo "ERROR: devcontainer config '$devcontfile'" 'is missing one of "image", "dockerFile" or "dockerComposeFile" properties.'
               exit 1
           fi    
       fi    

       if [[ "$volume_mode" == "true"  ]] 
       then
           # repo/folder data is put in volume and mounted in container (no bind done)
           if [[ "$contains_dockerComposeFile" == "true" ]]
           then
               echo "using docker compose to start a composition of containers (named volume mount done)"
           else  
               echo "using a single container using an image or dockerfile (named volume mount done)"
           fi    
           if [[ "$contains_workspaceFolder" == "true" && "$option_allow_workspacefolder_from_json" == "true" ]]
           then
              workspacefolder=$(grep -E  '^\s*"workspaceFolder' "$devcontfile" | sed 's/.*:\s*"//' |sed 's/"\s*,\s*$//')
              echo "explicit set in devcontainer.json the workspace folder for the dev container to: $workspacefolder"
           else    
              local basemountname
              basemountname=$(basename "$hostfolder")
              workspacefolder="/workspaces/$basemountname"
              echo "by default set workspace folder in dev container to volume mountdir: $workspacefolder"
           fi
       else
           # folder data is bind mounted into container
           if [[ "$contains_dockerComposeFile" == "true" ]]
           then
               echo "using docker compose to start a composition of containers (no bind done)"
               
               if [[ "$contains_workspaceFolder" == "true" ]]
               then
                  workspacefolder=$(grep -E  '^\s*"workspaceFolder' "$devcontfile" | sed 's/.*:\s*"//' |sed 's/"\s*,\s*$//')
                  echo "explicit set workspace folder in devcontainer to: $workspacefolder"
               else    
                  echo "no workspace folder for devcontainer specified"
                  echo "so set workspace folder in devcontainer to default: /"
               fi
           else  
               echo "using a single container using an image or dockerfile (bind mount done)"

               local basemountname
               local bindfolder
               basemountname=$(basename "$hostfolder")
               bindfolder="/workspaces/$basemountname"
               echo "by default local folder '$hostfolder' binded to folder '$bindfolder' in container"
               if [[ "$contains_workspaceFolder" == "true" ]]
               then
                  workspacefolder=$(grep -E  '^\s*"workspaceFolder' "$devcontfile" | sed 's/.*:\s*"//' |sed 's/"\s*,\s*$//')
                  echo "explicit set workspace folder in devcontainer to: $workspacefolder"
               else    
                  workspacefolder=$bindfolder
                  echo "no workspace folder in devcontainer config  specified"
                  echo "so set workspace folder in devcontainer config by default to binded folder: $bindfolder "
               fi   
           fi    
       fi    
   fi

   # using hostfolder and workspacefolder open the devcontainer    
   local hexencodedhostfolder
   hexencodedhostfolder=$(printf "%s" "$hostfolder" | xxd -p)
   hexencodedhostfolder=${hexencodedhostfolder//[[:space:]]/}
   code --folder-uri "vscode-remote://dev-container+$hexencodedhostfolder/$workspacefolder" 
   
   # from https://code.visualstudio.com/docs/remote/troubleshooting#_connect-to-a-remote-host-from-the-terminal
   # https://code.visualstudio.com/docs/remote/troubleshooting#_connect-to-a-remote-host-from-the-terminal
   # https://github.com/microsoft/vscode-remote-release/issues/2133#issuecomment-618328138
   # https://github.com/microsoft/vscode-remote-release/issues/2133#issuecomment-860863636
   # https://github.com/microsoft/vscode-remote-release/issues/2133#issuecomment-1212180962
   #  
   # we can use 
   #     code --folder-uri "vscode-remote://dev-container+$hexencodedhostfolder/$containerfolder"
   # or
   #     code --remote  dev-container+$hexencodedhostfolder $containerfolder
   #
   #
   # background info from # https://code.visualstudio.com/remote/advancedcontainers/change-default-source-mount:
   #
   #  If you add the image or dockerFile properties to devcontainer.json, VS Code will automatically "bind" mount your current workspace folder into the container.
   #   cases:
   #    -  https://github.com/microsoft/vscode-remote-try-python -> has "image": ..  => so mounts folder in /workspaces in container
   #    -  /Users/harcok/Documents/help/tools/web/cms_and_wiki_and_websitegenerators/pmwiki/pmwikiconf
   #         or 
   #       git@gitlab.science.ru.nl:harcok/pmwikiconf.git
   #        has ""dockerComposeFile: .. => but not "dockerFile" nor "image"  =>  so does not mount folder in /workspaces in container
   #           => in this case we must supply a workspaceFolder, otherwise vscode does not know which folder to open
   #              note: if not given, then vscode ask's for it in a dialog
   #  note: 
   #     special case in vscode itself: 
   #        Dev Containers: Clone repository in (named) container volume 
   #     then  
   #        vscode clones git in a (named) container volume and then 
   #        mounts this volume in /volumes and set it as the workspacefolder in vscode
   #        vscode ignores the fields WorkspaceFolder and workspaceMount in devcontainer.json 
}

code-remote "$@"
